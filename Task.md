В папке проект, задача: 1.  Контекст: Крупная книжная онлайн-платформа собирает данные о взаимодействиях пользователей с книгами. Данные разделены хронологически на несколько частей (чанков). Для этого этапа мы моделируем реальную ситуацию: у нас есть история взаимодействий пользователей до определённого момента времени (train.csv), и нам нужно предсказать оценку для их следующего взаимодействия в будущем (test.csv). Цель: Разработать модель машинного обучения, которая на основе истории взаимодействий пользователя (train.csv) предсказывает оценку (rating), которую этот пользователь поставит своей следующей прочитанной книге. Особенности задачи: * Временной разрыв: Обучающая выборка (train.csv) содержит данные за один период времени, а тестовая — за следующий. Это имитирует реальную задачу, где модель должна предсказывать будущие предпочтения. * Отсутствие "холодных" пользователей: В тестовую выборку включены только те пользователи, у которых есть история в обучающей выборке. Это позволяет сфокусироваться на качестве рекомендаций для существующей аудитории. * Одно предсказание на пользователя: Для каждого пользователя в тестовой выборке необходимо предсказать оценку только для одной, последней прочитанной им книги. Это классическая задача регрессии в контексте рекомендательных систем. Она проверяет навыки работы с разреженными табличными данными, генерации признаков и построения точных прогнозных моделей.  2. Бейзлайн-решение Для быстрого старта предоставлено бейзлайн-решение, которое можно и нужно использовать в качестве отправной точки для разработки собственного решения. Бейзлайн расположен по ссылке: https://github.com/Orange-Hack/nto-ai-25-26-individual-baseline.  Бейзлайн содержит: * Полностью рабочий пайплайн обучения и предсказания * Примеры feature engineering (агрегированные признаки, работа с текстом через TF-IDF и BERT) * Структуру проекта и необходимые утилиты для валидации решения Важно: Бейзлайн использует для обучения только книги с has_read=1 (книги, которым была поставлена оценка). Записи с has_read=0 исключаются из обучающей выборки. Это соответствует условию задачи, согласно которому предсказания делаются только для книг, которые были прочитаны и оценены. Рекомендуется изучить бейзлайн перед началом работы над задачей.  3. Данные Подробное описание структуры данных, полей и связей между таблицами вынесены в раздел "Данные". 4. Формат решения Подробное описание структуры данных, полей и связей между таблицами вынесены в раздел "Данные". 5. Метрика оценки Итоговый балл рассчитывается на основе двух стандартных метрик качества регрессии: среднеквадратичной ошибки (RMSE) и средней абсолютной ошибки (MAE). 5.1. Среднеквадратичная ошибка (RMSE) Показывает, насколько велики среднестатистические отклонения предсказаний от истинных значений. Формала: \mathrm{RMSE} = \sqrt{\frac{1}{N} \sum_{i=1}^N (\hat{y}_i - y_i)^2}  5.2. Средняя абсолютная ошибка (MAE) Показывает среднюю абсолютную разницу между предсказанными и истинными значениями. Формула: \mathrm{MAE} = \frac{1}{N} \sum_{i=1}^N |\hat{y}_i - y_i|  Где N — количество записей в выборке, y_i — истинная оценка, \hat{y}_i — предсказанная оценка. 5.3. Итоговый балл (Score) Для расчёта итогового балла ошибки нормализуются делением на ширину диапазона оценок (R=10). Финальный балл вычисляется как среднее арифметическое нормализованных ошибок, вычтенное из единицы. Чем выше Score, тем лучше результат. Формула: \mathrm{Score} = 1 - \left(0.5 \cdot \frac{\mathrm{RMSE}}{10} + 0.5 \cdot \frac{\mathrm{MAE}}{10}\right)  Лидерборд сортируется по убыванию значения Score.  6. Условия соревнования 6.1. Проверка и лидерборд * Публичный лидерборд (Public): Рассчитывается на видимой части тестовых данных. Результат обновляется после каждой успешной отправки решения. * Приватный лидерборд (Private): Рассчитывается на скрытой части тестовых данных. 6.2. Ограничения * Запрещено использовать любые внешние данные и предварительно обученные модели, за исключением общедоступных (например, для обработки текста). * Решение должно быть полностью автономным и не требовать доступа к сети Интернет во время работы. 1. Описание данных Основной формат исходных данных: CSV с разделителем точка с запятой (;) и двойными кавычками (") для экранирования текстовых полей.  1.1. Состав предоставляемых файлов Файл	Описание train.csv	Обучающая выборка, соответствующая первому хронологическому срезу данных (chunk 1). Содержит полную историю взаимодействий пользователей за этот период, включая прочитанные книги (has_read=1) и книги в списке "на прочтение" (has_read=0). test.csv	Тестовая выборка, содержащая взаимодействия из второго хронологического среза (chunk 2). Для каждого пользователя из тестовой выборки здесь представлена только одна пара (user_id, book_id), соответствующая его последнему прочитанному произведению. Важно: в test.csv включены только те пользователи, у которых есть достаточная история в train.csv. books.csv	Метаданные книг (автор, год публикации и т.д.). users.csv	Метаданные пользователей (пол, возраст). genres.csv	Справочник жанров. book_genres.csv	Таблица для связи книг и жанров (многие-ко-многим). book_descriptions.csv	Текстовые описания книг. Используется для извлечения признаков через TF-IDF и BERT. 1.2. Описание полей в метаданных train.csv: Обучающая выборка Поле	Тип	Описание user_id	int64	Уникальный идентификатор пользователя. book_id	int64	Уникальный идентификатор книги. has_read	int64	Флаг взаимодействия: 1 - книга прочитана и оценена, 0 - книга добавлена в список "на прочтение" (не оценена). rating	float64	Оценка книги по шкале от 0 до 10. Для записей с has_read=0 значение всегда равно 0 и является заглушкой. timestamp	str	Временная метка взаимодействия в формате YYYY-MM-DD HH:MM:SS. Важно: В бейзлайне для обучения используются только записи с has_read=1 (книги, которым была поставлена оценка). Записи с has_read=0 исключаются из обучающей выборки. Однако вполне вероятно, что использование записей сhas_read=0 улучшит значение метрики при правильном использовании.  Принципы формирования данных Хронологическое разделение: train.csv представляет собой первый по времени чанк данных (chunk_1), а данные для test.csv и solution.csv взяты из следующего чанка (chunk_2). Это гарантирует отсутствие утечек из будущего.  Фильтрация тестовой выборки: В test.csv попадают не все взаимодействия из chunk_2, а только специально отобранные:  Последнее взаимодействие: Для каждого пользователя берется только одно, самое последнее по времени взаимодействие с флагом has_read=1. Фильтр "теплых" пользователей: В test.csv включаются только те пользователи, у которых есть история в train.csv. Критерий: не менее 1 прочитанной книги (has_read=1) ИЛИ не менее 3 книг в списке "на прочтение" (has_read=0) в файле train.csv. Это гарантирует, что у участников будут исходные данные для всех пользователей из теста. Очистка данных: Из исходного набора данных были удалены аномальные записи, у которых has_read=0, но при этом rating > 0.  books.csv: Информация о книгах Поле	Тип	Описание book_id	int64	Уникальный идентификатор книги (первичный ключ). title	str	Название книги. author_id	int64	Уникальный идентификатор автора. author_name	str	Имя автора. publication_year	int64	Год публикации. language	int64	Числовой код языка книги. avg_rating	float64	Средняя оценка книги (рассчитана по всем взаимодействиям). publisher	int64	Числовой код издательства. users.csv: Информация о пользователях Поле	Тип	Описание user_id	int64	Уникальный идентификатор пользователя (первичный ключ). gender	int64	Пол пользователя (1 — мужской, 2 — женский). age	int64	Возраст пользователя. genres.csv: Справочник жанров Поле	Тип	Описание genre_id	int64	Уникальный идентификатор жанра (первичный ключ). genre_name	str	Название жанра. books_count	int64	Общее количество книг в данном жанре. book_genres.csv: Связь книг и жанров Поле	Тип	Описание book_id	int64	Идентификатор книги (внешний ключ к books.csv). genre_id	int64	Идентификатор жанра (внешний ключ к genres.csv). book_descriptions.csv: Описания книг Поле	Тип	Описание book_id	int64	Идентификатор книги (внешний ключ к books.csv). description	str	Текстовое описание книги. Может содержать пустые значения. Примечание: Описания используются для извлечения признаков двумя способами:  TF-IDF: создание разреженных признаков на основе термов и биграмм из описаний BERT embeddings: получение плотных векторных представлений текста через предобученную модель DeepPavlov/rubert-base-cased 2. Формат файла решения (сабмита) Файл с решением должен быть представлен в формате CSV с разделителем запятая (,). Файл может содержать заголовок, который будет проигнорирован при проверке.  Структура колонок: user_id,book_id,rating_predict  Требования:  user_id, book_id — идентификаторы, соответствующие парам из файла test.csv. Порядок строк в файле решения не важен. rating_predict — предсказанное значение оценки. Вещественное число в диапазоне от 0 до 10. Округлять не требуется. Система автоматически ограничит значения диапазоном [0, 10]. Файл должен содержать предсказания для всех пар из test.csv. Максимальный размер файла: 50 МБ. Пример содержимого submission.csv:  user_id,book_id,rating_predict 150,25357,7.854 150,18,9.102 24995,136814,5.500 

LLM и внешние данные: допустимо: применять LLM только офлайн как
детерминированный инструмент преобразования исключительно полей
предоставленного датасета. Разрешены публичные предобученные
энкодеры/модели при условии включения весов/версий в артефакты; вызовы
должны быть воспроизводимы офлайн (зафиксированы сиды, temperature=0,
версии библиотек). Все агрегаты/кластеры/профили считаются строго по
train-периоду.

Запрещено: любые сетевые обращения к API, сайтам


Запуск на Apple silicon, m4 max, 48GB RAM

